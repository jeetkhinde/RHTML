================================================================================
                       RHTML PROJECT STRUCTURE EXPLORATION
================================================================================

## 1. DEPENDENCIES (Cargo.toml)

Main App (rhtml_app):
  - axum (0.7)              # Web framework
  - tokio (1.0)             # Async runtime with full features
  - serde & serde_json      # Serialization
  - toml (0.8)              # Config file parsing
  - regex (1.10)            # Pattern matching
  - notify (6.1)            # File watching
  - tower-livereload (0.9)  # Browser live reload
  - urlencoding (2.1)       # URL encoding
  - anyhow, tracing         # Error handling & logging

rhtml-macro:
  - syn (2.0), quote, proc-macro2  # Procedural macro support

rhtml-router:
  - NO external dependencies! Only std library

rhtml-parser:
  - regex (1.10)

================================================================================
## 2. COMPONENT/PARTIAL IMPLEMENTATION

### A. COMPONENT SYNTAX (New cmp syntax)

File: components/Button.rs
```
cmp Button {
  <button class="btn">
    {text}
  </button>
}

css Button {
  .btn {
    padding: 0.75rem 1.5rem;
    ...
  }
}
```

### B. COMPONENT WITH @partial ANNOTATION

File: components/NotificationPartial.rs
```
@partial
struct NotificationProps {
    message: String,
    type: String,
}

NotificationPartial(props: NotificationProps) {
    <div class="notification notification-{type}">
        ...
    </div>
}

css NotificationPartial {
    .notification { ... }
}
```

When @partial is detected:
1. Component registered in components HashMap
2. Also registered as a partial route: /partials/notificationpartial

### C. NAMED PARTIALS IN PAGES

File: pages/users.rs
```
// Named partial 1
partial Stats(props: &PartialProps<()>) {
    <div class="bg-white rounded-lg">
        <h2>User Statistics</h2>
        ...
    </div>
}

// Named partial 2
partial ActiveUsers(props: &PartialProps<()>) {
    <div>...</div>
}

// Named partial 3
partial RecentActivity(props: &PartialProps<()>) {
    <div>...</div>
}

// Full page component
#[webpage]
fn page(props: PageProps) {
  <div class="container mx-auto">
    <h1>User Management</h1>
    <div id="stats-section">
      <button hx-get="/users?partial=Stats" hx-target="#stats-section">
        Load Stats
      </button>
    </div>
    ...
  </div>
}
```

Access via:
- /users?partial=Stats
- /users?partial=ActiveUsers
- /users?partial=RecentActivity

### D. AUTO-PARTIAL FILES

File: pages/partials/user-item.rs (NO WebPage component)
```
<!-- Partial: User list item (no Page component, just HTML) -->
<div class="user-item p-4 border-b hover:bg-gray-50">
    <div class="flex items-center justify-between">
        <div>
            <h3 class="font-semibold">{query_name}</h3>
            <p class="text-sm text-gray-600">{query_email}</p>
        </div>
        <span class="px-2 py-1 text-xs rounded bg-green-100">Active</span>
    </div>
</div>
```

When no WebPage component is found:
- Content is treated as a partial automatically
- Can be accessed directly as a route
- Rendered without layout

================================================================================
## 3. ROUTING SYSTEM IMPLEMENTATION

### A. FILE-BASED ROUTING (rhtml-router/src/lib.rs)

Router converts file paths to routes:
- pages/index.rs           → /
- pages/about.rs           → /about
- pages/users/index.rs     → /users
- pages/users/[id].rs      → /users/:id
- pages/docs/[...slug].rs  → /docs/*slug
- pages/posts/[id?].rs     → /posts/:id?
- pages/_layout.rs         → / (layout, not a route)
- pages/_error.rs          → / (error page, not a route)

### B. ROUTE PRIORITY SYSTEM

Static routes:       priority = 0
Optional param:      priority = depth + dynamic_count
Required dynamic:    priority = depth + dynamic_count + 1
Catch-all:           priority = 1000+ (lowest priority)

Routes sorted by priority, static routes checked first.

### C. ROUTE MATCHING

Key struct: Route {
    pattern: String,              // "/users/:id"
    template_path: String,
    params: Vec<String>,          // ["id"]
    priority: usize,
    is_layout: bool,
    has_catch_all: bool,
    optional_params: Vec<String>, // For [id?]
    is_error_page: bool,
}

Key struct: RouteMatch {
    route: Route,
    params: HashMap<String, String>, // {"id": "123"}
}

Router methods:
- add_route()          # Add a route
- match_route(path)    # Match incoming request
- get_layout(pattern)  # Get layout for route
- get_error_page()     # Get error page
- sort_routes()        # Sort by priority

================================================================================
## 4. QUERY PARAMETER HANDLING FOR ?partials=

### A. Request Flow (src/main.rs - render_route)

1. Create RequestContext with query params
2. Check for named partial request:
   ```rust
   if let Some(partial_name) = request_context.query.get("partial") {
       if partial_name != "true" {  // Distinguish from ?partial=true
           match renderer.render_named_partial(&page_template.content, partial_name) {
               Ok(html) => return Html(html).into_response(),
               Err(_) => {
                   let available = renderer.list_partials(&page_template.content);
                   return error_response(404, "Partial Not Found", ...);
               }
           }
       }
   }
   ```

3. If partial_name != "true", it's treated as a named partial name

### B. Renderer Methods (src/renderer.rs)

Four core methods for partial handling:

1. **list_partials(content: &str) -> Vec<String>**
   - Uses regex: r"partial\s+(\w+)\s*\("
   - Returns all partial names found
   - Used for error messages

2. **extract_named_partial(content: &str, name: &str) -> Result<String>**
   - Finds: partial {name}(...)
   - Uses brace depth tracking to extract content
   - Tracks { and } to find matching closing brace
   - Returns HTML content between braces

3. **render_named_partial(content: &str, name: &str) -> Result<String>**
   - Calls extract_named_partial()
   - Processes directives (r-if, r-for, etc.)
   - Processes interpolations ({variables})
   - Returns rendered HTML

4. **has_named_partials(content: &str) -> bool**
   - Quick check for "partial " keyword
   - Used to determine if page has partials

### C. Three Ways to Request Partials

1. Named partial: /users?partial=Stats (renders Stats partial)
2. Query param: /page?partial=true (renders without layout)
3. HTMX request: HX-Request header present (auto-partial mode)

================================================================================
## 5. MACRO IMPLEMENTATIONS (rhtml-macro/src/lib.rs)

### A. #[webpage] Attribute Macro

**Purpose:** Mark functions as page components, transform them to WebPage syntax

**Input:**
```rust
#[webpage]
pub fn users(props: UsersProps) {
    <div class="container">
        <h1>Users</h1>
        <div r-for="user in props.data">
            <user_card user={user} />
        </div>
    </div>
}
```

**Output:**
```rust
WebPage {
    <div class="container">
        <h1>Users</h1>
        <div r-for="user in props.data">
            <user_card user={user} />
        </div>
    </div>
}
```

**Processing Steps:**
1. Parse #[webpage] function with syn
2. Extract function body (HTML content)
3. Transform to WebPage { body } syntax
4. Return as proc-macro output

### B. Function Component Parser (rhtml-parser)

Methods in FunctionComponentParser:
- has_webpage_attribute(content)      # Check if #[webpage] present
- extract_webpage_function(content)   # Extract function body
- extract_braced_content(content)     # Extract content in braces
- remove_structs(content)             # Remove struct definitions
- process_content(content)            # Convert functions to WebPage syntax

The CssParser.process_template() calls this to:
1. Process #[webpage] functions to WebPage syntax
2. Extract and scope CSS blocks
3. Return (processed_content, scoped_css, partials)

================================================================================
## 6. HTML RENDERING FLOW (src/renderer.rs)

### A. Rendering Pipeline

render() method:
1. extract_html(content)        # Extract HTML from WebPage { ... }
2. process_directives(html)     # Process r-if, r-for, r-match, r-component
3. process_interpolations()     # Replace {variables} with values

### B. WebPage Component Extraction

extract_html() logic:
1. Skip slots { ... } block if present (complex brace matching)
2. Find "WebPage {" keyword
3. Find matching closing brace for the WebPage block
4. Return content between braces
5. If no WebPage found, return entire content (treat as partial)

### C. Directive Processing (process_directives)

Supported directives:
- r-if="condition"          # Conditional rendering
- r-else-if="condition"     # Else-if branch
- r-else                    # Else branch
- r-for="item in items"     # Loop iteration
- r-match="variable"        # Pattern matching
- r-when="value"            # Match case
- r-default                 # Match default
- r-component="Name"        # Component reference

Processing order:
1. Scan for opening tags
2. Identify directive types
3. Extract complete elements (tag + content + closing tag)
4. Process based on directive type
5. Replace in output buffer

### D. Component Processing (process_component)

process_component(tag) logic:
1. Extract r-component="ComponentName" directive
2. Extract props from tag attributes
3. Look up component from template_loader
4. Render component with available variables
5. Return rendered HTML

================================================================================
## 7. CONFIGURATION (src/config.rs)

Configuration structure from rhtml.toml:

[project]
name = "rhtml-app"
version = "0.1.0"

[server]
port = 3000
host = "127.0.0.1"
workers = 4

[routing]
pages_dir = "pages"
components_dir = "components"
case_insensitive = true
base_path = null        # Optional base path
trailing_slash = false

[build]
output_dir = "dist"
static_dir = "static"
minify_html = false
minify_css = false

[dev]
hot_reload = true
open_browser = false
watch_paths = ["pages", "components"]

================================================================================
## 8. EXISTING IMPLEMENTATIONS OVERVIEW

### A. Partially Implemented Features

1. **Named Partials** ✓ COMPLETE
   - partial Name(...) { ... } syntax in pages
   - ?partial=Name query parameter routing
   - list_partials() and extract_named_partial() methods
   - Error messages showing available partials

2. **@partial Annotation** ✓ IDENTIFIED
   - @partial struct annotation in components
   - Registered as /partials/{name} route
   - Example: components/NotificationPartial.rs

3. **Auto-Partials** ✓ COMPLETE
   - Files without WebPage component are auto-partials
   - Example: pages/partials/user-item.rs
   - Rendered without layout automatically

4. **Directives** ✓ IMPLEMENTED
   - r-if, r-else-if, r-else
   - r-for with loop variables
   - r-match / r-when / r-default (pattern matching)
   - r-component for component references

5. **CSS Scoping** ✓ IMPLEMENTED
   - css ScopeName { ... } blocks
   - Scoped via [data-rhtml="ComponentName"] attribute
   - Automatic extraction and removal from HTML

6. **Hot Reload** ✓ WORKING
   - notify crate for file watching
   - tower-livereload for browser reload
   - Template reloading without restart
   - Logs which templates were reloaded

7. **Layout System** ✓ WORKING
   - _layout.rs files as layouts
   - Section-specific layouts
   - slots { ... } for slot definitions
   - @layout(false) to skip layout
   - @layout("custom") for custom layout

================================================================================
## 9. KEY ENTRY POINTS

### Main Application Flow

1. **src/main.rs (main())**
   - Load config from rhtml.toml
   - Create TemplateLoader, load all templates
   - Setup hot reload watcher
   - Build Axum router with two routes:
     * GET/POST/PUT/DELETE /
     * GET/POST/PUT/DELETE /*path
   - Start server on 127.0.0.1:3000

2. **Handler: template_handler()**
   - Extract path, method, query, headers, body
   - Create RequestContext
   - Call render_route()

3. **render_route()**
   - Match route using router.match_route()
   - Get page template and layout template
   - Check for named partial request (?partial=Name)
   - Check for @layout directive
   - Create Renderer with loader
   - Render page with or without layout
   - Handle JSON content negotiation

4. **Renderer.render()**
   - Extract HTML from WebPage block
   - Process directives
   - Process interpolations
   - Return HTML string

================================================================================
## 10. TEMPLATE LOADER (src/template_loader.rs)

TemplateLoader responsibilities:
1. Load all templates from pages/ directory
2. Load all components from components/ directory
3. Create Router and add routes for all templates
4. Maintain HashMap of loaded templates
5. Maintain HashMap of loaded components

Key methods:
- load_all()                  # Load templates and components
- load_directory()            # Recursively load .rs files
- load_template()             # Load single template
- load_component()            # Load single component
- reload_template()           # Hot reload support
- get(route)                  # Get template by route
- get_component(name)         # Get component by name
- get_layout_for_route()      # Get layout for specific route
- router()                    # Get the Router instance

CSS Processing:
- Uses CssParser.process_template() to:
  1. Extract CSS blocks
  2. Scope CSS with component name
  3. Remove CSS from HTML
  4. Collect scoped CSS for rendering

================================================================================
## 11. CURRENT LIMITATIONS & NOTES

1. **Macro Crate (rhtml-macro)**
   - Currently only transforms #[webpage] syntax
   - Does NOT execute component macros from Rust code
   - Intended for compile-time syntax transformation only

2. **Partials**
   - @partial annotation is recognized but not fully integrated
   - Named partials work for explicit partial() blocks
   - Auto-partials work when WebPage component is absent

3. **Component Rendering**
   - r-component directive invokes component lookup
   - Components must be manually invoked in templates
   - Props are passed as HTML attributes

4. **Expression Evaluation**
   - Variables replaced via {variable} syntax
   - Complex expressions not supported
   - Uses ExpressionEvaluator from rhtml-parser

5. **Missing Piece**
   - The component macro implementation appears incomplete
   - Would be added to rhtml-macro crate
   - Would transform component function syntax to actual components

================================================================================
